/***************************************************************************//**
 * @file
 * @brief Top level application functions
 *******************************************************************************
 * # License
 * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
 *******************************************************************************
 *
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 ******************************************************************************/

#include <app.h>

/***************************************************************************//**
 * Globals.
 ******************************************************************************/
TaskHandle_t hTaskUart0;
TaskHandle_t hTaskBtn0;
TaskHandle_t hTaskBtn1;
TaskHandle_t hTaskLCD;
TaskHandle_t hTaskCursorBlink;

SemaphoreHandle_t RxValid;

QueueHandle_t UartData;

SegmentLCD_LowerCharSegments_TypeDef FIELD[SEGMENT_LCD_NUM_OF_LOWER_CHARS] = {0};
SegmentLCD_LowerCharSegments_TypeDef MAP[SEGMENT_LCD_NUM_OF_LOWER_CHARS];
SegmentLCD_LowerCharSegments_TypeDef CURSOR_POS[SEGMENT_LCD_NUM_OF_LOWER_CHARS] = {0};
SegmentLCD_LowerCharSegments_TypeDef HIT[SEGMENT_LCD_NUM_OF_LOWER_CHARS] = {0};

const unsigned onemilisec = 1000;
volatile char rx_data;
/***************************************************************************//**
 * ISRs.
 ******************************************************************************/
void UART0_RX_IRQHandler(void)
{
  BaseType_t xSwitchRequired;

  rx_data = USART_Rx(UART0);
  xSemaphoreGiveFromISR(RxValid, NULL);

  xSwitchRequired = xTaskResumeFromISR(hTaskUart0);

  portYIELD_FROM_ISR(xSwitchRequired);

}
void GPIO_ODD_IRQHandler() {
  BaseType_t xSwitchRequired;
  GPIO_IntClear(1 << PB0_PIN);
  xSwitchRequired = xTaskResumeFromISR(hTaskBtn0);

  portYIELD_FROM_ISR(xSwitchRequired);
}

void GPIO_EVEN_IRQHandler() {
  BaseType_t xSwitchRequired;

  GPIO_IntClear(1 << PB1_PIN);
  xSwitchRequired = xTaskResumeFromISR(hTaskBtn1);

  portYIELD_FROM_ISR(xSwitchRequired);
}

/***************************************************************************//**
 * FreeRTOS tasks.
 ******************************************************************************/
//sl_iostream_init_uart_instances.c SL_IOSTREAM_UART_RX_IRQ_HANDLER átírva
static void prvTaskUart0(void *pvParam){
  while(1){
    vTaskSuspend(NULL);
    xSemaphoreTake(RxValid, portMAX_DELAY);
    xQueueSend(UartData, &rx_data, portMAX_DELAY);
    //char c;
    //xQueueReceive(UartData, &c, portMAX_DELAY);
    //USART_Tx(UART0, c);
  }
}

static void prvTaskBtn0(void *pvParam) {
  while (1) {
      vTaskSuspend(NULL);
      const char* message = "PB0 has been pressed!\n";
      size_t length = strlen(message);
      size_t i;

      for (i = 0; i < length; i++) {
          char rx_data = message[i];
          USART_Tx(UART0, rx_data);
      }
  }
}

static void prvTaskBtn1(void *pvParam) {
  while (1) {
      vTaskSuspend(NULL);
      const char* message = "PB1 has been pressed!\n";
      size_t length = strlen(message);
      size_t i;

      for (i = 0; i < length; i++) {
          char rx_data = message[i];
          USART_Tx(UART0, rx_data);
      }
  }
}

static void prvTaskLCD(void *pvParam) {
  while(1){
      char c;
      SegmentLCD_LowerSegments(FIELD);
      xQueueReceive(UartData, &c, portMAX_DELAY);
      FieldMinusCursor(FIELD, CURSOR_POS);
      switch (c) {
        case 'w':
          moveUp(CURSOR_POS);
          break;
        case 's':
          moveDown(CURSOR_POS);
          break;
        case 'a':
          moveLeft(CURSOR_POS);
          break;
        case 'd':
          moveRight(CURSOR_POS);
          break;
        case '\n':
          SegmentLCD_ARingOnDelay(100);
          if(shoot(MAP, CURSOR_POS)){
              bool set = false;
              for(int i = 0; i < 4; i ++){
                SegmentLCD_ARingSet(set);
                set = !set;
                sl_udelay_wait(500 * onemilisec);
              }
            hit(HIT, CURSOR_POS);
          }
          else
            SegmentLCD_ARingSet(false);
          break;
        default:
          break;
      }
      FieldPlusCursor(FIELD, HIT);
      FieldPlusCursor(FIELD, CURSOR_POS);


  }
}

static void prvTaskCursorBlink(void *pvParam)  {
  static bool PlusOrMinus = true;
  while (1) {
      if(PlusOrMinus)
        FieldPlusCursor(FIELD, CURSOR_POS);
      else
        FieldMinusCursor(FIELD, CURSOR_POS);
      PlusOrMinus = !PlusOrMinus;
      SegmentLCD_LowerSegments(FIELD);
      vTaskDelay(pdMS_TO_TICKS(750));
  }
}
/***************************************************************************//**
 * Initialize application.
 ******************************************************************************/
void app_init(void)
{
  CHIP_Init();
  CMU_ClockEnable(cmuClock_GPIO, true);
  init_PB0();
  init_PB1();
  init_lcd();
  init_vcom();
  init_uart0();
  init_cursor(CURSOR_POS);
  init_map(MAP, 0);
  SegmentLCD_LowerSegments(MAP);

  RxValid = xSemaphoreCreateBinary();

  UartData = xQueueCreate(32, sizeof(uint8_t));
  if(UartData == NULL)
    NVIC_SystemReset();

  xTaskCreate(prvTaskUart0, "UART0",  configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 4, &hTaskUart0);
  xTaskCreate(prvTaskBtn0, "Btn0", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 3, &hTaskBtn0);
  xTaskCreate(prvTaskBtn1, "Btn1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 3, &hTaskBtn1);
  xTaskCreate(prvTaskLCD, "LCD",  configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 2, &hTaskLCD);
  xTaskCreate(prvTaskCursorBlink, "CursorBlink",  configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, &hTaskCursorBlink);

}

/***************************************************************************//**
 * App ticking function.
 ******************************************************************************/
void app_process_action(void)
{
}
