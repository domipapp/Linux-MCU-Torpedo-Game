/***************************************************************************//**
 * @file
 * @brief Top level application functions
 *******************************************************************************
 * # License
 * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
 *******************************************************************************
 *
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 ******************************************************************************/

#include <app.h>

/***************************************************************************//**
 * Globals.
 ******************************************************************************/
TaskHandle_t hTaskUart0;
TaskHandle_t hTaskLCD;
TaskHandle_t hTaskCursorBlink;

TimerHandle_t hMsTimer;

SemaphoreHandle_t RxValid;

QueueHandle_t UartData;

// Variable to be displayed
SegmentLCD_LowerCharSegments_TypeDef FIELD[SEGMENT_LCD_NUM_OF_LOWER_CHARS] = {0};
// variable to store hidden ships' positions
SegmentLCD_LowerCharSegments_TypeDef MAP[SEGMENT_LCD_NUM_OF_LOWER_CHARS];
// Variable to store current position of user cursor
SegmentLCD_LowerCharSegments_TypeDef CURSOR_POS[SEGMENT_LCD_NUM_OF_LOWER_CHARS] = {0};
// Variable to store which ships have been hit
SegmentLCD_LowerCharSegments_TypeDef HIT[SEGMENT_LCD_NUM_OF_LOWER_CHARS] = {0};

volatile char rx_data;  // Global variable to "transport" received UART data
uint32_t game_time_100ms = 0; // Count elapsed time since start in 100ms
/***************************************************************************//**
 * ISRs.
 ******************************************************************************/
// Handles received data and signals prvTaskUart0 that new data has arrived
void UART0_RX_IRQHandler(void)
{
  BaseType_t xSwitchRequired;

  rx_data = USART_Rx(UART0);
  xSemaphoreGiveFromISR(RxValid, NULL);// Signal prvTaskUart0

  xSwitchRequired = xTaskResumeFromISR(hTaskUart0);

  portYIELD_FROM_ISR(xSwitchRequired);

}

/***************************************************************************//**
 * Callbacks
 ******************************************************************************/
// Timer Callback function. Increments game_time_100ms every 100ms
void vTimerCallback(void){
  game_time_100ms ++;
}

/***************************************************************************//**
 * FreeRTOS tasks.
 ******************************************************************************/
//  Pushes received data into Queue
static void prvTaskUart0(void *pvParam){
  while(1){
    vTaskSuspend(NULL);
    xSemaphoreTake(RxValid, portMAX_DELAY);
    xQueueSend(UartData, &rx_data, portMAX_DELAY);
  }
}

// This task h
static void prvTaskLCD(void *pvParam) {
  static uint8_t shoots = 0;  // Variable to store shots made
  SegmentLCD_Number(shoots);  // Display "0000" on LCD display
  char startFrame[3] = {0};   // Variable to store first 2 bytes to check valid start protocol frame
  static uint8_t hits = 0;    // Variable to store ships hit. 8 hits sinks all ships
  static bool start = true;   // Variable to check if start protocol is to be checked

  while(1){
      char c; // Variable to temporarily store UART data
      if(start){  // Start protocol is to be checked
          // Wait for 2 characters
          xQueueReceive(UartData, &c, portMAX_DELAY);
          startFrame[strlen(startFrame)] = c;
          xQueueReceive(UartData, &c, portMAX_DELAY);
          startFrame[strlen(startFrame)] = c;
          if(strcmp(startFrame, "xx") == 0){  // Correct frame is xx'num' where 0 < 'num' < 16
              // Receive and check map initialiser value
              xQueueReceive(UartData, &c, portMAX_DELAY);
              unsigned num = (unsigned) c;
              if(num < 16)
                init_map(MAP, num);
              else  // In case of incorrect initialiser map 0 is default
                init_map(MAP, 0);
              // Create and start timer to count game time. Ticks are generated every 100ms
              hMsTimer = xTimerCreate(NULL, pdMS_TO_TICKS(100), pdTRUE, ( void * ) 0, vTimerCallback);
              xTimerStart(hMsTimer, portMAX_DELAY);
              start = false;
          }
          else{ // Frame error, restart control process
              memset(startFrame, '\0', sizeof(startFrame));
              continue;
          }
      }
      // Display Cursor and hit ships
      SegmentLCD_LowerSegments(FIELD);
      // Waits until there is new and valid data
      xQueueReceive(UartData, &c, portMAX_DELAY);
      // Remove Cursor as its position will be changed. Otherwise interference with prvTaskCursorBlink
      FieldMinusCursor(FIELD, CURSOR_POS);
      switch (c) {
        case 'w':
          moveUp(CURSOR_POS);
          break;
        case 's':
          moveDown(CURSOR_POS);
          break;
        case 'a':
          moveLeft(CURSOR_POS);
          break;
        case 'd':
          moveRight(CURSOR_POS);
          break;
        case '\n':
          // Increment and display new shoot value
          SegmentLCD_Number(++shoots);
          // Makes shooting effect
          SegmentLCD_ARingOnDelay(60);
          if(shoot(MAP, CURSOR_POS)){ // Check if ship has been hit
              if(isHit(HIT, CURSOR_POS))  // Check if ship has been hit previously
                break; // Break, so hit is not counted again
              // Blink ring 3 times to signal successful shot
              SegmentLCD_ARingBlink(7, false, 400);
              // Save ship being hit
              hit(HIT, CURSOR_POS);
              hits ++;
          }
          else  // Kill ring display to signal unsuccessful shoot
            SegmentLCD_ARingSet(false);
          break;
        default:
          break;
      }
      // Save all sunken ships
      FieldPlusHit(FIELD, HIT);
      // Display new cursor position
      FieldPlusCursor(FIELD, CURSOR_POS);
      if(hits == 8){  // End of game
          xTimerStop(hMsTimer, portMAX_DELAY);
          char buffer[12];  // Assuming 32-bit value can be represented in 12 characters (including null terminator)
          snprintf(buffer, sizeof(buffer), "%lu", game_time_100ms);  // Convert uint32_t to string to display in ASCII
          // Send the string over USART (pseudo-code)
          for (int i = 0; buffer[i] != '\0'; i++) {
              USART_Tx(UART0, buffer[i]);// Send buffer[i] character over USART
          }
          // Display WINNER string to signal successful completion of game
          SegmentLCD_Write("WINNER");
          vTaskSuspend(NULL); // Task is suspended to prevent display of other information
      }
  }
}

// This task blinks the current cursor position every 750 ms
static void prvTaskCursorBlink(void *pvParam)  {
  static bool PlusOrMinus = true; // Variable to check if segment needs to be turned on or off in order to display blinking effect
  while (1) {
      // Blink cursor
      if(PlusOrMinus)
        FieldPlusCursor(FIELD, CURSOR_POS); // Adds cursor to display
      else
        FieldMinusCursor(FIELD, CURSOR_POS);// Takes cursor out of display
      PlusOrMinus = !PlusOrMinus;
      // Display new configuration
      SegmentLCD_LowerSegments(FIELD);
      vTaskDelay(pdMS_TO_TICKS(750)); // Task runs every 750 ms
  }
}
/***************************************************************************//**
 * Initialize application.
 ******************************************************************************/
void app_init(void)
{
  CHIP_Init();
  CMU_ClockEnable(cmuClock_GPIO, true);
  init_PB0();
  init_PB1();
  init_lcd();
  init_vcom();
  init_uart0();
  init_cursor(CURSOR_POS);

  RxValid = xSemaphoreCreateBinary();

  UartData = xQueueCreate(32, sizeof(uint8_t));
  if(UartData == NULL)
    NVIC_SystemReset();

  xTaskCreate(prvTaskUart0, "UART0",  configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 3, &hTaskUart0);
  xTaskCreate(prvTaskLCD, "LCD",  configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 2, &hTaskLCD);
  xTaskCreate(prvTaskCursorBlink, "CursorBlink",  configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, &hTaskCursorBlink);

}

/***************************************************************************//**
 * App ticking function.
 ******************************************************************************/
void app_process_action(void)
{
}
