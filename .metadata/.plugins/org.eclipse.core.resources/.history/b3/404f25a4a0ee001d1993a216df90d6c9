/***************************************************************************//**
 * @file
 * @brief Top level application functions
 *******************************************************************************
 * # License
 * <b>Copyright 2020 Silicon Laboratories Inc. www.silabs.com</b>
 *******************************************************************************
 *
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 ******************************************************************************/

#include <stdio.h>

#include <FreeRTOS.h>
#include <task.h>
#include "sl_udelay.h"

#include <em_gpio.h>
#include <em_cmu.h>
#include <em_chip.h>
#include <em_usart.h>
#include "pin_config.h"
#include "caplesense.h"
#include "my_init.h"
#include "segmentlcd.h"

/***************************************************************************//**
 * Globals.
 ******************************************************************************/
TaskHandle_t hTaskBtn0;
TaskHandle_t hTaskBtn1;
TaskHandle_t hTaskLCD;
extern volatile uint32_t msTicks;//Sys_tick időszámláló, nulláról indul

void Delay(uint32_t dlyTicks){//dlyTicks miliszekundumig megállítja a program futását
  uint32_t curTicks;
  curTicks = msTicks;
  while ((msTicks - curTicks) < dlyTicks) ;
}


/***************************************************************************//**
 * ISRs.
 ******************************************************************************/
void GPIO_ODD_IRQHandler() {
  BaseType_t xSwitchRequired;
  GPIO_IntClear(1 << PB0_PIN);
  xSwitchRequired = xTaskResumeFromISR(hTaskBtn0);

  portYIELD_FROM_ISR(xSwitchRequired);
}

void GPIO_EVEN_IRQHandler() {
  BaseType_t xSwitchRequired;

  GPIO_IntClear(1 << PB1_PIN);
  xSwitchRequired = xTaskResumeFromISR(hTaskBtn1);

  portYIELD_FROM_ISR(xSwitchRequired);
}

/***************************************************************************//**
 * FreeRTOS tasks.
 ******************************************************************************/
static void prvTaskBtn0(void *pvParam) {
  while (1) {
      vTaskSuspend(NULL);
      printf("PB0 has been pressed!\n");
  }
}

static void prvTaskBtn1(void *pvParam) {
  while (1) {
      vTaskSuspend(NULL);
      printf("PB1 has been pressed!\n");
  }
}

static void prvTaskLCD(void *pvParam) {
  while (1) {
      SegmentLCD_Init(false);
      SegmentLCD_AllOn();
      sl_udelay_wait(2000000);
      SegmentLCD_AllOff();
      SegmentLCD_Disable();
      sl_udelay_wait(2000000);
  }
}
void UART1_RX_IRQHandler(void){
  printf("Data recieved!\n");
  NVIC_ClearPendingIRQ(UART1_RX_IRQn);
}
/***************************************************************************//**
 * Initialize application.
 ******************************************************************************/
void app_init(void)
{
  CHIP_Init();
  CMU_ClockEnable(cmuClock_GPIO, true);
  init_PB0();
  init_PB1();
  NVIC_EnableIRQ(UART1_RX_IRQn);
  SysTick_Config(CMU_ClockFreqGet(cmuClock_CORE) / 1000);
  xTaskCreate(prvTaskBtn0, "Btn0", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 2, &hTaskBtn0);
  xTaskCreate(prvTaskBtn1, "Btn1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 2, &hTaskBtn1);
  xTaskCreate(prvTaskLCD, "LCD",  configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY + 1, &hTaskLCD);

}

/***************************************************************************//**
 * App ticking function.
 ******************************************************************************/
void app_process_action(void)
{
}
